/** Promise start */
window.Promise = undefined;
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){W=t}function r(t){z=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof U?function(){U(a)}:c()}function s(){var t=0,e=new H(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<N;t+=2){var e=Q[t],n=Q[t+1];e(n),Q[t]=void 0,Q[t+1]=void 0}N=0}function f(){try{var t=Function("return this")().require("vertx");return U=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[V]&&x(r);var o=n._state;if(o){var i=arguments[o-1];z(function(){return T(o,r,i,n._result)})}else j(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return w(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function y(t,e,n){z(function(t){var r=!1,o=_(n,e,function(n){r||(r=!0,e!==n?w(t,n):A(t,n))},function(e){r||(r=!0,S(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,S(t,o))},t)}function m(t,e){e._state===Z?A(t,e._result):e._state===$?S(t,e._result):j(e,void 0,function(e){return w(t,e)},function(e){return S(t,e)})}function b(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?m(t,n):void 0===r?A(t,n):e(r)?y(t,n,r):A(t,n)}function w(e,n){if(e===n)S(e,v());else if(t(n)){var r=void 0;try{r=n.then}catch(o){return void S(e,o)}b(e,n,r)}else A(e,n)}function g(t){t._onerror&&t._onerror(t._result),E(t)}function A(t,e){t._state===X&&(t._result=e,t._state=Z,0!==t._subscribers.length&&z(E,t))}function S(t,e){t._state===X&&(t._state=$,t._result=e,z(g,t))}function j(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+Z]=n,o[i+$]=r,0===i&&t._state&&z(E,t)}function E(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?T(n,r,o,i):o(i);t._subscribers.length=0}}function T(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=!0;if(i){try{s=r(o)}catch(a){c=!1,u=a}if(n===s)return void S(n,d())}else s=o;n._state!==X||(i&&c?w(n,s):c===!1?S(n,u):t===Z?A(n,s):t===$&&S(n,s))}function M(t,e){try{e(function(e){w(t,e)},function(e){S(t,e)})}catch(n){S(t,n)}}function P(){return tt++}function x(t){t[V]=tt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function C(){return new Error("Array Methods must be provided an Array")}function O(t){return new et(this,t).promise}function k(t){var e=this;return new e(L(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function F(t){var e=this,n=new e(p);return S(n,t),n}function Y(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function q(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function D(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=nt}var K=void 0;K=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var L=K,N=0,U=void 0,W=void 0,z=function(t,e){Q[N]=t,Q[N+1]=e,N+=2,2===N&&(W?W(a):R())},B="undefined"!=typeof window?window:void 0,G=B||{},H=G.MutationObserver||G.WebKitMutationObserver,I="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),J="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,Q=new Array(1e3),R=void 0;R=I?o():H?s():J?u():void 0===B&&"function"==typeof require?f():c();var V=Math.random().toString(36).substring(2),X=void 0,Z=1,$=2,tt=0,et=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[V]||x(this.promise),L(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?A(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&A(this.promise,this._result))):S(this.promise,C())}return t.prototype._enumerate=function(t){for(var e=0;this._state===X&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=void 0,i=void 0,s=!1;try{o=t.then}catch(u){s=!0,i=u}if(o===l&&t._state!==X)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===nt){var c=new n(p);s?S(c,i):b(c,t,o),this._willSettleAt(c,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===X&&(this._remaining--,t===$?S(r,n):this._result[e]=n),0===this._remaining&&A(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;j(t,void 0,function(t){return n._settledAt(Z,e,t)},function(t){return n._settledAt($,e,t)})},t}(),nt=function(){function t(e){this[V]=P(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&Y(),this instanceof t?M(this,e):q())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return nt.prototype.then=l,nt.all=O,nt.race=k,nt.resolve=h,nt.reject=F,nt._setScheduler=n,nt._setAsap=r,nt._asap=z,nt.polyfill=D,nt.Promise=nt,nt.polyfill(),nt});
/** Promise end */
/** fetch start */
function isDataView(a){return a&&DataView.prototype.isPrototypeOf(a)}function normalizeName(a){if("string"!=typeof a&&(a=String(a)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(a)||""===a)throw new TypeError("Invalid character in header field name");return a.toLowerCase()}function normalizeValue(a){return"string"!=typeof a&&(a=String(a)),a}function iteratorFor(a){var b={next:function(){var b=a.shift();return{done:void 0===b,value:b}}};return support.iterable&&(b[Symbol.iterator]=function(){return b}),b}function Headers(a){this.map={},a instanceof Headers?a.forEach(function(a,b){this.append(b,a)},this):Array.isArray(a)?a.forEach(function(a){this.append(a[0],a[1])},this):a&&Object.getOwnPropertyNames(a).forEach(function(b){this.append(b,a[b])},this)}function consumed(a){return a.bodyUsed?Promise.reject(new TypeError("Already read")):(a.bodyUsed=!0,void 0)}function fileReaderReady(a){return new Promise(function(b,c){a.onload=function(){b(a.result)},a.onerror=function(){c(a.error)}})}function readBlobAsArrayBuffer(a){var b=new FileReader,c=fileReaderReady(b);return b.readAsArrayBuffer(a),c}function readBlobAsText(a){var b=new FileReader,c=fileReaderReady(b);return b.readAsText(a),c}function readArrayBufferAsText(a){var d,b=new Uint8Array(a),c=new Array(b.length);for(d=0;d<b.length;d++)c[d]=String.fromCharCode(b[d]);return c.join("")}function bufferClone(a){if(a.slice)return a.slice(0);var b=new Uint8Array(a.byteLength);return b.set(new Uint8Array(a)),b.buffer}function Body(){return this.bodyUsed=!1,this._initBody=function(a){this._bodyInit=a,a?"string"==typeof a?this._bodyText=a:support.blob&&Blob.prototype.isPrototypeOf(a)?this._bodyBlob=a:support.formData&&FormData.prototype.isPrototypeOf(a)?this._bodyFormData=a:support.searchParams&&URLSearchParams.prototype.isPrototypeOf(a)?this._bodyText=a.toString():support.arrayBuffer&&support.blob&&isDataView(a)?(this._bodyArrayBuffer=bufferClone(a.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):support.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(a)||isArrayBufferView(a))?this._bodyArrayBuffer=bufferClone(a):this._bodyText=a=Object.prototype.toString.call(a):this._bodyText="",this.headers.get("content-type")||("string"==typeof a?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):support.searchParams&&URLSearchParams.prototype.isPrototypeOf(a)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},support.blob&&(this.blob=function(){var a=consumed(this);if(a)return a;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?consumed(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(readBlobAsArrayBuffer)}),this.text=function(){var a=consumed(this);if(a)return a;if(this._bodyBlob)return readBlobAsText(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},support.formData&&(this.formData=function(){return this.text().then(decode)}),this.json=function(){return this.text().then(JSON.parse)},this}function normalizeMethod(a){var b=a.toUpperCase();return methods.indexOf(b)>-1?b:a}function Request(a,b){b=b||{};var c=b.body;if(a instanceof Request){if(a.bodyUsed)throw new TypeError("Already read");this.url=a.url,this.credentials=a.credentials,b.headers||(this.headers=new Headers(a.headers)),this.method=a.method,this.mode=a.mode,this.signal=a.signal,c||null==a._bodyInit||(c=a._bodyInit,a.bodyUsed=!0)}else this.url=String(a);if(this.credentials=b.credentials||this.credentials||"same-origin",(b.headers||!this.headers)&&(this.headers=new Headers(b.headers)),this.method=normalizeMethod(b.method||this.method||"GET"),this.mode=b.mode||this.mode||null,this.signal=b.signal||this.signal,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&c)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(c)}function decode(a){var b=new FormData;return a.trim().split("&").forEach(function(a){var c,d,e;a&&(c=a.split("="),d=c.shift().replace(/\+/g," "),e=c.join("=").replace(/\+/g," "),b.append(decodeURIComponent(d),decodeURIComponent(e)))}),b}function parseHeaders(a){var b=new Headers,c=a.replace(/\r?\n[\t ]+/g," ");return c.split(/\r?\n/).forEach(function(a){var e,c=a.split(":"),d=c.shift().trim();d&&(e=c.join(":").trim(),b.append(d,e))}),b}function Response(a,b){b||(b={}),this.type="default",this.status=void 0===b.status?200:b.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in b?b.statusText:"OK",this.headers=new Headers(b.headers),this.url=b.url||"",this._initBody(a)}function fetch(a,b){return new Promise(function(c,d){function g(){f.abort()}var f,e=new Request(a,b);return e.signal&&e.signal.aborted?d(new DOMException("Aborted","AbortError")):(f=new XMLHttpRequest,f.onload=function(){var b,a={status:f.status,statusText:f.statusText,headers:parseHeaders(f.getAllResponseHeaders()||"")};a.url="responseURL"in f?f.responseURL:a.headers.get("X-Request-URL"),b="response"in f?f.response:f.responseText,c(new Response(b,a))},f.onerror=function(){d(new TypeError("Network request failed"))},f.ontimeout=function(){d(new TypeError("Network request failed"))},f.onabort=function(){d(new DOMException("Aborted","AbortError"))},f.open(e.method,e.url,!0),"include"===e.credentials?f.withCredentials=!0:"omit"===e.credentials&&(f.withCredentials=!1),"responseType"in f&&support.blob&&(f.responseType="blob"),e.headers.forEach(function(a,b){f.setRequestHeader(b,a)}),e.signal&&(e.signal.addEventListener("abort",g),f.onreadystatechange=function(){4===f.readyState&&e.signal.removeEventListener("abort",g)}),f.send("undefined"==typeof e._bodyInit?null:e._bodyInit),void 0)})}var viewClasses,isArrayBufferView,methods,redirectStatuses,DOMException,support={searchParams:"URLSearchParams"in self,iterable:"Symbol"in self&&"iterator"in Symbol,blob:"FileReader"in self&&"Blob"in self&&function(){try{return new Blob,!0}catch(a){return!1}}(),formData:"FormData"in self,arrayBuffer:"ArrayBuffer"in self};support.arrayBuffer&&(viewClasses=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],isArrayBufferView=ArrayBuffer.isView||function(a){return a&&viewClasses.indexOf(Object.prototype.toString.call(a))>-1}),Headers.prototype.append=function(a,b){a=normalizeName(a),b=normalizeValue(b);var c=this.map[a];this.map[a]=c?c+", "+b:b},Headers.prototype["delete"]=function(a){delete this.map[normalizeName(a)]},Headers.prototype.get=function(a){return a=normalizeName(a),this.has(a)?this.map[a]:null},Headers.prototype.has=function(a){return this.map.hasOwnProperty(normalizeName(a))},Headers.prototype.set=function(a,b){this.map[normalizeName(a)]=normalizeValue(b)},Headers.prototype.forEach=function(a,b){for(var c in this.map)this.map.hasOwnProperty(c)&&a.call(b,this.map[c],c,this)},Headers.prototype.keys=function(){var a=[];return this.forEach(function(b,c){a.push(c)}),iteratorFor(a)},Headers.prototype.values=function(){var a=[];return this.forEach(function(b){a.push(b)}),iteratorFor(a)},Headers.prototype.entries=function(){var a=[];return this.forEach(function(b,c){a.push([c,b])}),iteratorFor(a)},support.iterable&&(Headers.prototype[Symbol.iterator]=Headers.prototype.entries),methods=["DELETE","GET","HEAD","OPTIONS","POST","PUT"],Request.prototype.clone=function(){return new Request(this,{body:this._bodyInit})},Body.call(Request.prototype),Body.call(Response.prototype),Response.prototype.clone=function(){return new Response(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new Headers(this.headers),url:this.url})},Response.error=function(){var a=new Response(null,{status:0,statusText:""});return a.type="error",a},redirectStatuses=[301,302,303,307,308],Response.redirect=function(a,b){if(-1===redirectStatuses.indexOf(b))throw new RangeError("Invalid status code");return new Response(null,{status:b,headers:{location:a}})},DOMException=self.DOMException;try{new DOMException}catch(err){DOMException=function(a,b){this.message=a,this.name=b;var c=Error(a);this.stack=c.stack},DOMException.prototype=Object.create(Error.prototype),DOMException.prototype.constructor=DOMException}fetch.polyfill=!0,self.fetch||(self.fetch=fetch,self.Headers=Headers,self.Request=Request,self.Response=Response);
/** fetch end */
/** 封装fetch start  */
(function () {
  /**
   * 本类在浏览器自带的Fetch基础上,封装的一个具有出错重复请求的类,
   * 如果接口需要轮询,请直接使用fetch,减少内存开销
   * @param url 请求地址
   * @param catchData 请求附带的设置对象
   */
  var FetchRequest = /** @class */ (function () {
    function FetchRequest(url, catch_data) {
      var _this = this;
      //重复尝试次数
      this.try_times = 2;
      //重复尝试间隔时间
      this.interval_time = 500;
      this.try_timeout = undefined;
      //传递结果的Promise
      this.res_promise = undefined;
      this.res_promise_resolve = undefined;
      this.res_promise_reject = undefined;

      //请求地址
      this.url = url;
      //附带发送的数据
      this.catch_data = catch_data;

      //实例化一个传递结果的promise,并代理其resolve和reject
      this.res_promise = new Promise(function (resolve, reject) {
        _this.res_promise_resolve = resolve;
        _this.res_promise_reject = reject;
        _this.try_request();
      });
    }
    FetchRequest.prototype.try_request = function () {
      //还有尝试次数
      if (this.try_times > 0) {
        --this.try_times;
        this.request();
      }
      //没有尝试次数了,退出
      else {
        this.request_fail();
      }
    };
    FetchRequest.prototype.request = function () {
      var _this = this;
      fetch(this.url, this.catch_data).then(function (res) {
        if (res.ok) {
          _this.request_success(res);
        }
        else {
          throw new Error("服务器连通,但未正常响应请求");
        }
      })["catch"](function (error) {
        console.warn("请求", _this.url, "发生错误,继续尝试:", error);
        clearTimeout(_this.try_timeout);
        _this.try_timeout = setTimeout(function () {
          _this.try_request();
        }, _this.interval_time);
      });
    };
    /**接口请求成功 */
    FetchRequest.prototype.request_success = function (res) {
      this.res_promise_resolve(res);
      this.clear_memory();
    };
    /**接口请求失败 */
    FetchRequest.prototype.request_fail = function () {
      console.error("请求失败,重试次数耗尽", this.url);
      this.res_promise_reject();
      this.clear_memory();
    };
    /**清理内存*/
    FetchRequest.prototype.clear_memory = function () {
      clearTimeout(this.try_timeout);
      this.res_promise_resolve = undefined;
      this.res_promise_reject = undefined;
    };
    return FetchRequest;
  }());
  window.fetchRequest = function (url, catchData) {
    return new FetchRequest(url, catchData).res_promise;
  };
  /**
  * 用于请求js文件,带错误重试
  * 放于全局作用域下加载
  * @param url 请求地址
  * @param datakey 该js加载后,会生成的全局变量名称,用来检查js是否正确加载,如js里有多个,写其中一个
  * */
  function FetchScript(url, datakey) {
    /**重复发起几次请求,直到次数耗尽或请求成功,默认2次 */
    this.tryTimes = 2;
    this.intervalTime = 500;
    this.url = url;
    this.datakey = datakey;
    /**借位的promise对象,代替原生fetch返回的promise响应 */
    this.promise = new Promise(function (resolve, reject) {
      if (window[datakey]) {
        resolve(window[datakey]);
        return;
      }
      var tryFunction = function () {
        --this.tryTimes;
        var jsonpScript = document.createElement('script');
        jsonpScript.setAttribute('src', `${this.url}?${Date.now() / 100000 >> 0}`);
        jsonpScript.onerror = function (error) {
          document.getElementsByTagName('head')[0].removeChild(jsonpScript);
          if (this.tryTimes > 0) {
            console.warn(`请求${this.url}失败,继续尝试:`, error);
            setTimeout(function () {
              tryFunction();
            }.bind(this), this.intervalTime);
          } else {
            reject(`请求${this.url}次数耗尽,请检查服务情况`);
            console.error(`请求${this.url}次数耗尽,请检查服务情况:`, error);
          }
        }.bind(this);
        jsonpScript.onload = function () {
          document.getElementsByTagName('head')[0].removeChild(jsonpScript);
          var data = window[datakey];
          if (!data) {
            jsonpScript.onerror();
            return;
          }
          resolve(data);
        }.bind(this);
        document.getElementsByTagName('head')[0].appendChild(jsonpScript);
      }.bind(this);
      tryFunction();
    }.bind(this));
  };
  window.fetchScript = function (url, datakey) {
    return new FetchScript(url, datakey).promise;
  };
})(window);
/** 封装fetch end  */
/**
 * 封装Jquery请求类,若请求失败,会重复请求
 * params:{
 * tryTimes:尝试次数,默认3次,
 * tryInterval:每次尝试间隔时间,默认500毫秒
 * $requestType:ajax和getScript,必填,不同类型的接口对应的处理方式不一样,
 * successBack:必填,执行成功回调.
 * errorBack:请求发生错误回调函数,每次发生错误都会执行.该函数必须返回false不发起/true发起,告知错误处理方法是否继续发起下一次请求.
 * failBack:尝试次数用尽,执行失败回调,回调都绑定在改请求对象下执行.
 * timeOut:超时时间,在请求类型为ajax下有效
 * data:在请求类型为ajax下使用,,指$.ajax(data),不要包含url,success和error回调函数,使用apiUrl,successBack和failBack
 * apiUrl:必填.
 * attach:附加的对象,可以把某些对象存在这里.
 * }
 * 注意,若使用jsonp,编译相关的参数正常还一直报parsererror错,八成是服务器返回的不是标准json数据,有3种方法:
 * 1要求服务返回正常数据,不能是var 某某值 = {}这种类型,必须是纯{};
 * 2在不能修改的情况下,推荐这个方法,已在示例里更新.在data,添加参数jsonpCallback:test//自己定,再添加一个dataFilter方法:function(data,type){test(某某值)};
 * 3尝试次数设置为1,在data里添加complete函数来处理,complete里能拿到 某某值 这个变量.successBack设置为空函数,
 * **/
window.RequestApi = function (params) {
  //类型判断
  if (!(this instanceof RequestApi)) return new RequestApi(params);

  /**数据部分*/
  this.tryTimes = params['tryTimes'] || 3;
  this.timeOut = params['timeOut'] || 2000;
  this.tryInterval = params['tryInterval'] || 800;
  this.apiUrl = params.apiUrl;
  this.$requestType = params.$requestType;
  this.successBack = params.successBack;
  this.failBack = params['failBack'] || null;
  this.params = params;
  this.request$ = null;
  this.errorBack = params['errorBack'] || function () {
      return true;
  };
  this.attach = params['attach'] || null;
  /**数据部分 end*/

  /**方法部分*/
  this.requestOne = function (immediately) {
      //判断请求时间
      var delayTime = immediately ? 0 : this.tryInterval;
      //尝试关闭上一个请求
      this.request$ && this.request$.abort();
      if (this.tryTimes === 0) {
          //请求次数用尽,执行失败函数
          this.failBack && this.failBack();
      } else {
          //次数减一
          --this.tryTimes;
          //判断是否选择延后处理
          setTimeout(function () {
              switch (this.$requestType) {
                  case 'ajax': {
                      this.ajax();
                      break;
                  }
                  case 'getScript': {
                      this.getScript();
                      break;
                  }
              }
          }.bind(this), delayTime);
      }
  };
  this.handleError = function(XMLHttpRequest, textStatus){
      console.log("失败: " + this.apiUrl, textStatus);
      //执行error回调,判断是否应该自动发起下一次尝试
      this.errorBack(XMLHttpRequest, textStatus) && this.requestOne();
  };
  this.ajax = function () {
      var data = this.params.data;
      data['success'] = function (data) {
          this.successBack(data);
      }.bind(this);
      data['timeout'] = this.timeOut;
      data['error'] = this.handleError.bind(this);
      data['url'] = this.apiUrl;
      this.request$ = $.ajax(data);
  };
  this.getScript = function () {
      this.request$ = $.getScript(this.params.apiUrl).done(this.successBack.bind(this)).fail(this.handleError.bind(this));
  };
  /**方法部分 end*/

  //初始化完成,执行第一次尝试
  this.requestOne(true);
};